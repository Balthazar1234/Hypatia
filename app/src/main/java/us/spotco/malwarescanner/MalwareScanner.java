/*
Hypatia: A realtime malware scanner for Android
Copyright (c) 2017-2018 Divested Computing Group

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/
package us.spotco.malwarescanner;

import android.content.Context;
import android.os.AsyncTask;
import android.os.Environment;
import android.os.SystemClock;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

class MalwareScanner extends AsyncTask<Set<File>, Object, String> {

    private boolean userFacing;
    private long scanTime = 0;
    private int hashMaxLength;
    private final HashMap<String, File> fileHashesMD5 = new HashMap<>();
    private final HashMap<String, File> fileHashesSHA1 = new HashMap<>();
    private final HashMap<String, File> fileHashesSHA256 = new HashMap<>();

    public MalwareScanner(Context context, boolean userFacing) {
        this.userFacing = userFacing;
        hashMaxLength = Utils.getPrefs(context).getInt("database_hash_length", 12);
    }

    private void returnResult(String result, boolean userFacingOnly) {
        //TODO HANDLE STATUS UPDATES
    }

    @Override
    protected final void onPreExecute() {
        scanTime = SystemClock.elapsedRealtime();
        returnResult(Utils.getContext().getString(R.string.main_starting_scan), true);
    }

    @Override
    protected final String doInBackground(Set<File>[] filesToScan) {
        //Pre
        fileHashesMD5.clear();
        fileHashesSHA1.clear();
        fileHashesSHA256.clear();

        publishProgress( Utils.getContext().getString(R.string.main_files_pending_scan, filesToScan[0].size() + "") + "\n", true);

        DatabaseManager.loadAllAvailableDatabases(false);
        if (Signatures.getSignatureCount() >= 0) {
            publishProgress(Utils.getContext().getString(R.string.main_database_loaded, Signatures.getSignatureCount() + "") + "\n", true);

            //Get file hashes
            publishProgress(Utils.getContext().getString(R.string.main_hashing_files), true);
            for (File file : filesToScan[0]) {
                getFileHashes(file);
            }
            publishProgress(Utils.getContext().getString(R.string.main_hashing_done) + "\n", true);

            //Check the hashes
            checkSignature("MD5", fileHashesMD5, Signatures.MD5);
            checkSignature("SHA-1", fileHashesSHA1, Signatures.SHA1);
            checkSignature("SHA-256", fileHashesSHA256, Signatures.SHA256);

            //Post
            fileHashesMD5.clear();
            fileHashesSHA1.clear();
            fileHashesSHA256.clear();
            System.gc();
            Utils.amtFilesScanned += filesToScan[0].size();
            publishProgress(Utils.getContext().getString(R.string.main_scanning_done, ((SystemClock.elapsedRealtime() - scanTime) / 1000) + "") + "\n\n\n\n", true);
        } else {
            publishProgress(Utils.getContext().getString(R.string.main_no_database_available), true);
        }
        return null;
    }

    @Override
    protected final void onProgressUpdate(Object... objects) {
        returnResult((String) objects[0], (boolean) objects[1]);
    }

    private void checkSignature(String hashType, HashMap<String, File> signaturesToCheck, HashMap<String, String> signatureDatabase) {
        if (signatureDatabase.size() > 0) {
            for (Map.Entry<String, File> file : signaturesToCheck.entrySet()) {
                if (signatureDatabase.containsKey(file.getKey())) {
                    String result = signatureDatabase.get(file.getKey());
                    publishProgress(result + " in " + file.getValue().toString().replaceAll(Environment.getExternalStorageDirectory().toString(), "~"), false);
                }
            }
            publishProgress(Utils.getContext().getString(R.string.main_hash_scan_done, hashType) + "\n", true);
        } else {
            publishProgress(Utils.getContext().getString(R.string.main_no_hashes_available, hashType) + "\n", true);
        }
    }

    private void getFileHashes(File file) {
        try {
            InputStream fis = new FileInputStream(file);

            byte[] buffer = new byte[4096];
            int numRead;

            MessageDigest digestMD5 = MessageDigest.getInstance("MD5");
            MessageDigest digestSHA1 = MessageDigest.getInstance("SHA-1");
            MessageDigest digestSHA256 = MessageDigest.getInstance("SHA-256");

            do {
                numRead = fis.read(buffer);
                if (numRead > 0) {
                    digestMD5.update(buffer, 0, numRead);
                    digestSHA1.update(buffer, 0, numRead);
                    digestSHA256.update(buffer, 0, numRead);
                }
            } while (numRead != -1);

            fis.close();

            fileHashesMD5.put(String.format("%032x", new BigInteger(1, digestMD5.digest())).substring(0, hashMaxLength), file);
            fileHashesSHA1.put(String.format("%032x", new BigInteger(1, digestSHA1.digest())).substring(0, hashMaxLength), file);
            fileHashesSHA256.put(String.format("%064x", new BigInteger(1, digestSHA256.digest())).substring(0, hashMaxLength), file);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
